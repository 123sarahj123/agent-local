package process

import (
	"io"
	"regexp"
)

// This regex matches either newline, or one of the "Erase in Line" escape
// sequences:
// [K Clear from cursor to the end of the line
// [1K Clear from cursor to beginning of the line
// [2K Clear entire line
var lineBreakEscapeRE = regexp.MustCompile(`\n|\x1b\[[012]?K`)

// Prefixer inserts prefixes generated by a callback before each line. To ensure
// any temporarily-buffered data is written out, be sure to call Flush when
// done.
type Prefixer struct {
	w  io.Writer
	f  func() string
	st bool // at start of line
}

// NewPrefixer sets up a Prefixer outputting to an io.Writer w and reading
// prefixes from the callback f.
func NewPrefixer(w io.Writer, f func() string) *Prefixer {
	return &Prefixer{
		w:  w,
		f:  f,
		st: true,
	}
}

// Write writes the given data, plus any additional prefixes necessary, to the
// Prefixer's output. Prefixes are computed at the *start* of each line.
func (p *Prefixer) Write(data []byte) (n int, err error) {
	written := 0
	for len(data) > 0 {
		// When at the start of a line, write a prefix.
		if p.st {
			// Prefixes are not included in the written total.
			if _, err := p.w.Write([]byte(p.f())); err != nil {
				return written, err
			}
			p.st = false
		}

		// Find the next newline or line-break escape sequence.
		// FindIndex returns a two-element slice denoting the matched range.
		idx := lineBreakEscapeRE.FindIndex(data)
		if idx == nil {
			// Write all remaining data. The line continues into the next Write
			// call.
			n, err := p.w.Write(data)
			written += n
			return written, err
		}

		// Write up to (and including) the newline / breaking sequence, ready to
		// start a new line in the next iteration or Write.
		n, err := p.w.Write(data[:idx[1]])
		written += n
		if err != nil {
			return written, err
		}
		data = data[idx[1]:]
		p.st = true
	}
	return written, nil
}
